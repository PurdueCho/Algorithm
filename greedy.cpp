/*
    그리디(Greedy)
    '당장 눈 앞에 보이는 최적의 상황만을 쫓는 알고리즘'
    항상 최적의 결과를 도출하는 것은 아니지만 어느정도 최적의 해에 근사한 값을 빠르게 구할 수 있다는 장점이 있다.
    '특정한 상횡'에서는 최적의 해를 보장 할 수도 있다

    기본적으로 무조건 큰 경우대로, 무조건 작은 경우대로, 무조건 긴 경우대로, 무조건 짧은 경우대로 등으로
    극단적으로 문제에 접근한다는 점에서 정렬기법이 함께 사용되는 경우가 많다.
    예) 크루스칼 : 모든 간선을 정렬한 이후에 짧은 간선부터 연결하는 최소신장비용 트리
    
*/

#include <iostream>

using namespace std;

int main (void) {
    // 거스름돈을 거슬러 줄때 가장 적은 화폐로 거슬러 주는 경우의 수
    int n, result = 0;
    cin >> n;
    result += n / 500;
    n%=500;
    result += n / 100;
    n%=100;
    result += n / 50;
    n%=50;
    result += n / 10;
    n%=10;
    cout << result;
    return 0;
}

